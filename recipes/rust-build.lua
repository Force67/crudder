-- Rust build.rs recipe
-- Generates a single flat module for use with include!() in build.rs
-- Similar to tonic-build's approach

return {
    name = "rust-build",
    description = "Rust code for build.rs (single file output)",
    generate = function(schema, ctx)
        local sqlx = ctx:option("sqlx")

        local code = helpers.lines()
            :add("// Generated by crudder-build. Do not edit.")
            :blank()

        -- =====================================================================
        -- Types module
        -- =====================================================================
        code:block("pub mod types {", "}", function(b)
            b:add("use serde::{Deserialize, Serialize};")

            if sqlx then
                b:add("use sqlx::FromRow;")
            end

            -- Check what we need to import
            local needs_uuid = false
            local needs_chrono = false
            for _, dto in ipairs(schema.dtos) do
                for _, field in ipairs(dto.fields) do
                    local base = field.ty:base_type()
                    if base.primitive == "uuid" then needs_uuid = true end
                    if base.primitive == "timestamp" then needs_chrono = true end
                end
            end

            if needs_uuid then b:add("use uuid::Uuid;") end
            if needs_chrono then b:add("use chrono::{DateTime, Utc};") end
            b:blank()

            -- Generate structs
            for _, dto in ipairs(schema.dtos) do
                local derives = { "Debug", "Clone", "Serialize", "Deserialize" }
                if sqlx and dto:is_entity() then
                    table.insert(derives, "FromRow")
                end

                b:add("#[derive(" .. table.concat(derives, ", ") .. ")]")
                b:add('#[serde(rename_all = "camelCase")]')
                b:block("pub struct " .. dto.name .. " {", "}", function(s)
                    for _, field in ipairs(dto.fields) do
                        local rust_ty = helpers.rust_type(field.ty)
                        local field_name = helpers.to_snake_case(field.name)
                        s:add("pub " .. field_name .. ": " .. rust_ty .. ",")
                    end
                end)
                b:blank()
            end
        end)

        code:blank()

        -- =====================================================================
        -- Service handlers
        -- =====================================================================
        for _, service in ipairs(schema.services) do
            local service_name_snake = helpers.to_snake_case(service.name)

            -- Find the entity this service manages
            local entity = nil
            local entity_table = nil
            for _, dto in ipairs(schema.dtos) do
                if dto:is_entity() then
                    entity = dto
                    entity_table = dto:table_name()
                    break
                end
            end

            -- Imports for service
            code:add("use axum::{")
            code:indent()
            code:add("extract::{Path, State},")
            code:add("http::StatusCode,")
            code:add("routing::{get, post, put, delete},")
            code:add("Json, Router,")
            code:dedent()
            code:add("};")

            if sqlx == "postgres" then
                code:add("use sqlx::PgPool;")
                code:add("pub type AppState = PgPool;")
            elseif sqlx == "sqlite" then
                code:add("use sqlx::SqlitePool;")
                code:add("pub type AppState = SqlitePool;")
            else
                code:add("pub type AppState = ();")
            end

            code:blank()

            -- Router function
            code:block("pub fn " .. service_name_snake .. "_router() -> Router<AppState> {", "}", function(r)
                r:add("Router::new()")
                r:indent()
                for _, method in ipairs(service.methods) do
                    local fn_name = helpers.to_snake_case(method.name)
                    local http_method = method:http_method() or "GET"
                    local http_path = method:http_path() or "/"
                    local axum_path = string.gsub(http_path, "{([^}]+)}", ":%1")
                    r:add('.route("' .. axum_path .. '", ' .. http_method:lower() .. '(' .. fn_name .. '))')
                end
                r:dedent()
            end)

            code:blank()

            -- Handler functions
            for _, method in ipairs(service.methods) do
                local fn_name = helpers.to_snake_case(method.name)
                local http_method = method:http_method() or "GET"
                local http_path = method:http_path() or "/"

                -- Extract path parameters
                local path_params = {}
                for param in string.gmatch(http_path, "{([^}]+)}") do
                    table.insert(path_params, param)
                end

                -- Build signature
                local params = { "State(pool): State<AppState>" }
                if #path_params == 1 then
                    table.insert(params, "Path(" .. path_params[1] .. "): Path<String>")
                elseif #path_params > 1 then
                    table.insert(params, "Path((" .. table.concat(path_params, ", ") .. ")): Path<(" .. string.rep("String, ", #path_params):sub(1, -3) .. ")>")
                end

                local has_body = (http_method == "POST" or http_method == "PUT" or http_method == "PATCH") and method.input ~= "Empty"
                if has_body then
                    table.insert(params, "Json(payload): Json<types::" .. method.input .. ">")
                end

                local return_type = "StatusCode"
                if method.output and method.output ~= "Empty" then
                    return_type = "Result<Json<types::" .. method.output .. ">, StatusCode>"
                end

                code:add("pub async fn " .. fn_name .. "(")
                code:indent()
                for i, param in ipairs(params) do
                    local suffix = i < #params and "," or ""
                    code:add(param .. suffix)
                end
                code:dedent()
                code:block(") -> " .. return_type .. " {", "}", function(b)
                    -- Generate SQLx implementation if available
                    if sqlx and entity then
                        local pk_field = entity:primary_key()
                        local pk_name = pk_field and helpers.to_snake_case(pk_field.name) or "id"

                        if http_method == "GET" and not string.find(http_path, "{") then
                            -- List
                            local output_dto = schema:get_dto(method.output)
                            if output_dto then
                                local list_field = nil
                                for _, f in ipairs(output_dto.fields) do
                                    if f.ty.kind == "array" then list_field = f break end
                                end
                                if list_field then
                                    local list_name = helpers.to_snake_case(list_field.name)
                                    b:add('let ' .. list_name .. ' = sqlx::query_as::<_, types::' .. entity.name .. '>(')
                                    b:add('    "SELECT * FROM ' .. entity_table .. ' ORDER BY created_at DESC"')
                                    b:add(')')
                                    b:add('.fetch_all(&pool)')
                                    b:add('.await')
                                    b:add('.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;')
                                    b:blank()
                                    b:add('Ok(Json(types::' .. method.output .. ' { ' .. list_name .. ' }))')
                                else
                                    b:add("Err(StatusCode::NOT_IMPLEMENTED)")
                                end
                            else
                                b:add("Err(StatusCode::NOT_IMPLEMENTED)")
                            end

                        elseif http_method == "GET" and #path_params > 0 then
                            -- Get by ID
                            b:add('let ' .. pk_name .. ' = ' .. path_params[1] .. '.parse::<uuid::Uuid>().map_err(|_| StatusCode::BAD_REQUEST)?;')
                            b:blank()
                            b:add('let result = sqlx::query_as::<_, types::' .. entity.name .. '>(')
                            b:add('    "SELECT * FROM ' .. entity_table .. ' WHERE ' .. pk_name .. ' = $1"')
                            b:add(')')
                            b:add('.bind(' .. pk_name .. ')')
                            b:add('.fetch_optional(&pool)')
                            b:add('.await')
                            b:add('.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;')
                            b:blank()
                            b:add('result.map(Json).ok_or(StatusCode::NOT_FOUND)')

                        elseif http_method == "POST" then
                            -- Create
                            local insert_fields = {}
                            local placeholders = {}
                            local binds = {}
                            local idx = 1
                            for _, field in ipairs(entity.fields) do
                                if not field:is_auto() then
                                    local col_name = helpers.to_snake_case(field.name)
                                    table.insert(insert_fields, col_name)
                                    table.insert(placeholders, "$" .. idx)
                                    idx = idx + 1

                                    local input_dto = schema:get_dto(method.input)
                                    local found = false
                                    if input_dto then
                                        for _, f in ipairs(input_dto.fields) do
                                            if f.name == field.name then found = true break end
                                        end
                                    end
                                    if found then
                                        table.insert(binds, '.bind(&payload.' .. helpers.to_snake_case(field.name) .. ')')
                                    elseif field.ty.primitive == "bool" then
                                        table.insert(binds, '.bind(false)')
                                    elseif field.ty.primitive == "uuid" then
                                        table.insert(binds, '.bind(uuid::Uuid::nil())')
                                    else
                                        table.insert(binds, '.bind("")')
                                    end
                                end
                            end

                            b:add('let result = sqlx::query_as::<_, types::' .. entity.name .. '>(')
                            b:add('    "INSERT INTO ' .. entity_table .. ' (' .. table.concat(insert_fields, ", ") .. ') VALUES (' .. table.concat(placeholders, ", ") .. ') RETURNING *"')
                            b:add(')')
                            for _, bind in ipairs(binds) do b:add(bind) end
                            b:add('.fetch_one(&pool)')
                            b:add('.await')
                            b:add('.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;')
                            b:blank()
                            b:add('Ok(Json(result))')

                        elseif http_method == "PUT" or http_method == "PATCH" then
                            -- Update
                            b:add('let ' .. pk_name .. ' = ' .. path_params[1] .. '.parse::<uuid::Uuid>().map_err(|_| StatusCode::BAD_REQUEST)?;')
                            b:blank()

                            local input_dto = schema:get_dto(method.input)
                            if input_dto then
                                local sets = {}
                                local binds = {}
                                local idx = 1
                                for _, field in ipairs(input_dto.fields) do
                                    local col = helpers.to_snake_case(field.name)
                                    table.insert(sets, col .. ' = COALESCE($' .. idx .. ', ' .. col .. ')')
                                    table.insert(binds, '.bind(&payload.' .. col .. ')')
                                    idx = idx + 1
                                end

                                b:add('let result = sqlx::query_as::<_, types::' .. entity.name .. '>(')
                                b:add('    "UPDATE ' .. entity_table .. ' SET ' .. table.concat(sets, ", ") .. ' WHERE ' .. pk_name .. ' = $' .. idx .. ' RETURNING *"')
                                b:add(')')
                                for _, bind in ipairs(binds) do b:add(bind) end
                                b:add('.bind(' .. pk_name .. ')')
                                b:add('.fetch_optional(&pool)')
                                b:add('.await')
                                b:add('.map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;')
                                b:blank()
                                b:add('result.map(Json).ok_or(StatusCode::NOT_FOUND)')
                            else
                                b:add("Err(StatusCode::NOT_IMPLEMENTED)")
                            end

                        elseif http_method == "DELETE" then
                            -- Delete
                            b:add('let ' .. pk_name .. ' = match ' .. path_params[1] .. '.parse::<uuid::Uuid>() {')
                            b:add('    Ok(id) => id,')
                            b:add('    Err(_) => return StatusCode::BAD_REQUEST,')
                            b:add('};')
                            b:blank()
                            b:add('let result = match sqlx::query(')
                            b:add('    "DELETE FROM ' .. entity_table .. ' WHERE ' .. pk_name .. ' = $1"')
                            b:add(')')
                            b:add('.bind(' .. pk_name .. ')')
                            b:add('.execute(&pool)')
                            b:add('.await {')
                            b:add('    Ok(r) => r,')
                            b:add('    Err(_) => return StatusCode::INTERNAL_SERVER_ERROR,')
                            b:add('};')
                            b:blank()
                            b:add('if result.rows_affected() > 0 {')
                            b:add('    StatusCode::NO_CONTENT')
                            b:add('} else {')
                            b:add('    StatusCode::NOT_FOUND')
                            b:add('}')
                        else
                            if method.output and method.output ~= "Empty" then
                                b:add("Err(StatusCode::NOT_IMPLEMENTED)")
                            else
                                b:add("StatusCode::NOT_IMPLEMENTED")
                            end
                        end
                    else
                        if method.output and method.output ~= "Empty" then
                            b:add("Err(StatusCode::NOT_IMPLEMENTED)")
                        else
                            b:add("StatusCode::NOT_IMPLEMENTED")
                        end
                    end
                end)
                code:blank()
            end
        end

        ctx:emit_file("generated.rs", code:build())
        ctx:log("Generated single-file Rust module for build.rs")
    end
}
