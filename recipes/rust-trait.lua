-- Rust trait-based recipe
-- Generates a service trait that users implement with custom logic
-- Similar to tonic-build's approach

return {
    name = "rust-trait",
    description = "Rust service trait (user implements handlers)",
    generate = function(schema, ctx)
        local sqlx = ctx:option("sqlx")

        local code = helpers.lines()
            :add("// Generated by crudder-build. Do not edit.")
            :add("//")
            :add("// Implement the generated trait to add custom handler logic:")
            :add("//")
            :add("// ```")
            :add("// struct MyService { pool: PgPool }")
            :add("//")
            :add("// #[async_trait]")
            :add("// impl TodoService for MyService {")
            :add("//     async fn list_todos(&self) -> Result<TodoList, StatusCode> {")
            :add("//         // your custom logic here")
            :add("//     }")
            :add("// }")
            :add("// ```")
            :blank()
            :add("use axum::{")
            :indent()
            :add("async_trait,")
            :add("extract::{FromRef, Path, State},")
            :add("http::StatusCode,")
            :add("routing::{get, post, put, delete},")
            :add("Json, Router,")
            :dedent()
            :add("};")
            :add("use std::sync::Arc;")
            :blank()

        -- =====================================================================
        -- Types module
        -- =====================================================================
        code:block("pub mod types {", "}", function(b)
            b:add("use serde::{Deserialize, Serialize};")

            if sqlx then
                b:add("use sqlx::FromRow;")
            end

            local needs_uuid = false
            local needs_chrono = false
            for _, dto in ipairs(schema.dtos) do
                for _, field in ipairs(dto.fields) do
                    local base = field.ty:base_type()
                    if base.primitive == "uuid" then needs_uuid = true end
                    if base.primitive == "timestamp" then needs_chrono = true end
                end
            end

            if needs_uuid then b:add("use uuid::Uuid;") end
            if needs_chrono then b:add("use chrono::{DateTime, Utc};") end
            b:blank()

            for _, dto in ipairs(schema.dtos) do
                local derives = { "Debug", "Clone", "Serialize", "Deserialize" }
                if sqlx and dto:is_entity() then
                    table.insert(derives, "FromRow")
                end

                b:add("#[derive(" .. table.concat(derives, ", ") .. ")]")
                b:add('#[serde(rename_all = "camelCase")]')
                b:block("pub struct " .. dto.name .. " {", "}", function(s)
                    for _, field in ipairs(dto.fields) do
                        local rust_ty = helpers.rust_type(field.ty)
                        local field_name = helpers.to_snake_case(field.name)
                        s:add("pub " .. field_name .. ": " .. rust_ty .. ",")
                    end
                end)
                b:blank()
            end
        end)

        code:blank()
        :add("pub use types::*;")
        :blank()

        -- =====================================================================
        -- Service traits
        -- =====================================================================
        for _, service in ipairs(schema.services) do
            local trait_name = service.name
            local service_snake = helpers.to_snake_case(service.name)

            -- Generate the trait
            code:add("/// Service trait - implement this with your custom logic.")
            code:add("#[axum::async_trait]")
            code:block("pub trait " .. trait_name .. ": Send + Sync + 'static {", "}", function(t)
                for _, method in ipairs(service.methods) do
                    local fn_name = helpers.to_snake_case(method.name)
                    local http_method = method:http_method() or "GET"
                    local http_path = method:http_path() or "/"

                    -- Extract path parameters
                    local path_params = {}
                    for param in string.gmatch(http_path, "{([^}]+)}") do
                        table.insert(path_params, param)
                    end

                    -- Build method signature
                    local params = {}
                    params[1] = "&self"

                    for _, p in ipairs(path_params) do
                        table.insert(params, p .. ": String")
                    end

                    local has_body = (http_method == "POST" or http_method == "PUT" or http_method == "PATCH") and method.input ~= "Empty"
                    if has_body then
                        table.insert(params, "request: " .. method.input)
                    end

                    local return_type = "StatusCode"
                    if method.output and method.output ~= "Empty" then
                        return_type = "Result<" .. method.output .. ", StatusCode>"
                    end

                    -- Add doc comment
                    t:add("/// " .. http_method .. " " .. http_path)
                    t:add("async fn " .. fn_name .. "(" .. table.concat(params, ", ") .. ") -> " .. return_type .. ";")
                    t:blank()
                end
            end)

            code:blank()

            -- Generate the router builder
            code:add("/// Creates an Axum router from a service implementation.")
            code:block("pub fn " .. service_snake .. "_router<S>(service: S) -> Router where S: " .. trait_name .. " + Clone {", "}", function(r)
                r:add("let service = Arc::new(service);")
                r:blank()
                r:add("Router::new()")
                r:indent()

                for _, method in ipairs(service.methods) do
                    local fn_name = helpers.to_snake_case(method.name)
                    local http_method = method:http_method() or "GET"
                    local http_path = method:http_path() or "/"
                    local axum_path = string.gsub(http_path, "{([^}]+)}", ":%1")
                    local handler_name = "__" .. fn_name .. "_handler"

                    r:add('.route("' .. axum_path .. '", ' .. http_method:lower() .. '(' .. handler_name .. '::<S>))')
                end

                r:add(".with_state(service)")
                r:dedent()
            end)

            code:blank()

            -- Generate handler wrappers
            for _, method in ipairs(service.methods) do
                local fn_name = helpers.to_snake_case(method.name)
                local http_method = method:http_method() or "GET"
                local http_path = method:http_path() or "/"
                local handler_name = "__" .. fn_name .. "_handler"

                local path_params = {}
                for param in string.gmatch(http_path, "{([^}]+)}") do
                    table.insert(path_params, param)
                end

                local has_body = (http_method == "POST" or http_method == "PUT" or http_method == "PATCH") and method.input ~= "Empty"

                local return_type = "StatusCode"
                if method.output and method.output ~= "Empty" then
                    return_type = "Result<Json<" .. method.output .. ">, StatusCode>"
                end

                -- Build handler signature
                local handler_params = { "State(service): State<Arc<S>>" }
                if #path_params == 1 then
                    table.insert(handler_params, "Path(" .. path_params[1] .. "): Path<String>")
                elseif #path_params > 1 then
                    table.insert(handler_params, "Path((" .. table.concat(path_params, ", ") .. ")): Path<(" .. string.rep("String, ", #path_params):sub(1, -3) .. ")>")
                end
                if has_body then
                    table.insert(handler_params, "Json(request): Json<" .. method.input .. ">")
                end

                code:add("async fn " .. handler_name .. "<S: " .. trait_name .. ">(")
                code:indent()
                for i, param in ipairs(handler_params) do
                    local suffix = i < #handler_params and "," or ""
                    code:add(param .. suffix)
                end
                code:dedent()
                code:block(") -> " .. return_type .. " {", "}", function(h)
                    -- Build call to trait method
                    local call_args = {}
                    for _, p in ipairs(path_params) do
                        table.insert(call_args, p)
                    end
                    if has_body then
                        table.insert(call_args, "request")
                    end

                    local call = "service." .. fn_name .. "(" .. table.concat(call_args, ", ") .. ").await"

                    if method.output and method.output ~= "Empty" then
                        h:add(call .. ".map(Json)")
                    else
                        h:add(call)
                    end
                end)

                code:blank()
            end
        end

        ctx:emit_file("generated.rs", code:build())
        ctx:log("Generated trait-based Rust module")
    end
}
